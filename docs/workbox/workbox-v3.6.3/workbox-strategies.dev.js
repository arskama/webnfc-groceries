this.workbox=this.workbox||{},this.workbox.strategies=function(n,i,m,h,g,N){"use strict";try{self.workbox.v["workbox:strategies:3.6.3"]=1}catch(e){}const O=e=>{const t=new URL(e,location);return t.origin===location.origin?t.pathname:t.href};var l={strategyStart:(e,t)=>`Using ${e} to respond to '${O(t.url)}'`,printFinalResponse:e=>{e&&(n.logger.groupCollapsed("View the final response here."),n.logger.unprefixed.log(e),n.logger.groupEnd())}};class f{constructor(e={}){this._cacheName=m.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions||null,this._matchOptions=e.matchOptions||null}handle({event:e}){var t=this;return babelHelpers.asyncToGenerator(function*(){return i.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"CacheFirst",funcName:"handle",paramName:"event"}),t.makeRequest({event:e,request:e.request})})()}makeRequest({event:e,request:t}){var s=this;return babelHelpers.asyncToGenerator(function*(){const r=[];typeof t=="string"&&(t=new Request(t)),i.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"CacheFirst",funcName:"makeRequest",paramName:"request"});let a=yield h.cacheWrapper.match({cacheName:s._cacheName,request:t,event:e,matchOptions:s._matchOptions,plugins:s._plugins}),o;if(a)r.push(`Found a cached response in the '${s._cacheName}' cache.`);else{r.push(`No response found in the '${s._cacheName}' cache. Will respond with a network request.`);try{a=yield s._getFromNetwork(t,e)}catch(c){o=c}a?r.push("Got response from network."):r.push("Unable to get a response from the network.")}{n.logger.groupCollapsed(l.strategyStart("CacheFirst",t));for(let c of r)n.logger.log(c);l.printFinalResponse(a),n.logger.groupEnd()}if(o)throw o;return a})()}_getFromNetwork(e,t){var s=this;return babelHelpers.asyncToGenerator(function*(){const r=yield g.fetchWrapper.fetch({request:e,event:t,fetchOptions:s._fetchOptions,plugins:s._plugins}),a=r.clone(),o=h.cacheWrapper.put({cacheName:s._cacheName,request:e,response:a,event:t,plugins:s._plugins});if(t)try{t.waitUntil(o)}catch(c){n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${N.getFriendlyURL(t.request.url)}'.`)}return r})()}}class w{constructor(e={}){this._cacheName=m.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._matchOptions=e.matchOptions||null}handle({event:e}){var t=this;return babelHelpers.asyncToGenerator(function*(){return i.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"CacheOnly",funcName:"handle",paramName:"event"}),t.makeRequest({event:e,request:e.request})})()}makeRequest({event:e,request:t}){var s=this;return babelHelpers.asyncToGenerator(function*(){typeof t=="string"&&(t=new Request(t)),i.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"CacheOnly",funcName:"makeRequest",paramName:"request"});const r=yield h.cacheWrapper.match({cacheName:s._cacheName,request:t,event:e,matchOptions:s._matchOptions,plugins:s._plugins});return n.logger.groupCollapsed(l.strategyStart("CacheOnly",t)),r?(n.logger.log(`Found a cached response in the '${s._cacheName}' cache.`),l.printFinalResponse(r)):n.logger.log(`No response found in the '${s._cacheName}' cache.`),n.logger.groupEnd(),r})()}}var d={cacheWillUpdate:({response:e})=>e.ok||e.status===0?e:null};class v{constructor(e={}){if(this._cacheName=m.cacheNames.getRuntimeName(e.cacheName),e.plugins){let t=e.plugins.some(s=>!!s.cacheWillUpdate);this._plugins=t?e.plugins:[d,...e.plugins]}else this._plugins=[d];this._networkTimeoutSeconds=e.networkTimeoutSeconds,this._networkTimeoutSeconds&&i.assert.isType(this._networkTimeoutSeconds,"number",{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"constructor",paramName:"networkTimeoutSeconds"}),this._fetchOptions=e.fetchOptions||null,this._matchOptions=e.matchOptions||null}handle({event:e}){var t=this;return babelHelpers.asyncToGenerator(function*(){return i.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"handle",paramName:"event"}),t.makeRequest({event:e,request:e.request})})()}makeRequest({event:e,request:t}){var s=this;return babelHelpers.asyncToGenerator(function*(){const r=[];typeof t=="string"&&(t=new Request(t)),i.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"handle",paramName:"makeRequest"});const a=[];let o;if(s._networkTimeoutSeconds){const{id:p,promise:b}=s._getTimeoutPromise({request:t,event:e,logs:r});o=p,a.push(b)}const c=s._getNetworkPromise({timeoutId:o,request:t,event:e,logs:r});a.push(c);let u=yield Promise.race(a);u||(u=yield c);{n.logger.groupCollapsed(l.strategyStart("NetworkFirst",t));for(let p of r)n.logger.log(p);l.printFinalResponse(u),n.logger.groupEnd()}return u})()}_getTimeoutPromise({request:e,logs:t,event:s}){var r=this;let a;const o=new Promise(c=>{const u=(()=>{var p=babelHelpers.asyncToGenerator(function*(){t.push(`Timing out the network response at ${r._networkTimeoutSeconds} seconds.`),c(yield r._respondFromCache({request:e,event:s}))});return function(){return p.apply(this,arguments)}})();a=setTimeout(u,this._networkTimeoutSeconds*1e3)});return{promise:o,id:a}}_getNetworkPromise({timeoutId:e,request:t,logs:s,event:r}){var a=this;return babelHelpers.asyncToGenerator(function*(){let o,c;try{c=yield g.fetchWrapper.fetch({request:t,event:r,fetchOptions:a._fetchOptions,plugins:a._plugins})}catch(u){o=u}if(e&&clearTimeout(e),c?s.push("Got response from network."):s.push("Unable to get a response from the network. Will respond with a cached response."),o||!c)c=yield a._respondFromCache({request:t,event:r}),c?s.push(`Found a cached response in the '${a._cacheName}' cache.`):s.push(`No response found in the '${a._cacheName}' cache.`);else{const u=c.clone(),p=h.cacheWrapper.put({cacheName:a._cacheName,request:t,response:u,event:r,plugins:a._plugins});if(r)try{r.waitUntil(p)}catch(b){n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${N.getFriendlyURL(r.request.url)}'.`)}}return c})()}_respondFromCache({event:e,request:t}){return h.cacheWrapper.match({cacheName:this._cacheName,request:t,event:e,matchOptions:this._matchOptions,plugins:this._plugins})}}class _{constructor(e={}){this._cacheName=m.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions||null}handle({event:e}){var t=this;return babelHelpers.asyncToGenerator(function*(){return i.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"NetworkOnly",funcName:"handle",paramName:"event"}),t.makeRequest({event:e,request:e.request})})()}makeRequest({event:e,request:t}){var s=this;return babelHelpers.asyncToGenerator(function*(){typeof t=="string"&&(t=new Request(t)),i.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"NetworkOnly",funcName:"handle",paramName:"request"});let r,a;try{a=yield g.fetchWrapper.fetch({request:t,event:e,fetchOptions:s._fetchOptions,plugins:s._plugins})}catch(o){r=o}if(n.logger.groupCollapsed(l.strategyStart("NetworkOnly",t)),a?n.logger.log("Got response from network."):n.logger.log("Unable to get a response from the network."),l.printFinalResponse(a),n.logger.groupEnd(),r)throw r;return a})()}}class k{constructor(e={}){if(this._cacheName=m.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],e.plugins){let t=e.plugins.some(s=>!!s.cacheWillUpdate);this._plugins=t?e.plugins:[d,...e.plugins]}else this._plugins=[d];this._fetchOptions=e.fetchOptions||null,this._matchOptions=e.matchOptions||null}handle({event:e}){var t=this;return babelHelpers.asyncToGenerator(function*(){return i.assert.isInstance(e,FetchEvent,{moduleName:"workbox-strategies",className:"StaleWhileRevalidate",funcName:"handle",paramName:"event"}),t.makeRequest({event:e,request:e.request})})()}makeRequest({event:e,request:t}){var s=this;return babelHelpers.asyncToGenerator(function*(){const r=[];typeof t=="string"&&(t=new Request(t)),i.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"StaleWhileRevalidate",funcName:"handle",paramName:"request"});const a=s._getFromNetwork({request:t,event:e});let o=yield h.cacheWrapper.match({cacheName:s._cacheName,request:t,event:e,matchOptions:s._matchOptions,plugins:s._plugins});if(o){if(r.push(`Found a cached response in the '${s._cacheName}' cache. Will update with the network response in the background.`),e)try{e.waitUntil(a)}catch(c){n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${N.getFriendlyURL(e.request.url)}'.`)}}else r.push(`No response found in the '${s._cacheName}' cache. Will wait for the network response.`),o=yield a;{n.logger.groupCollapsed(l.strategyStart("StaleWhileRevalidate",t));for(let c of r)n.logger.log(c);l.printFinalResponse(o),n.logger.groupEnd()}return o})()}_getFromNetwork({request:e,event:t}){var s=this;return babelHelpers.asyncToGenerator(function*(){const r=yield g.fetchWrapper.fetch({request:e,event:t,fetchOptions:s._fetchOptions,plugins:s._plugins}),a=h.cacheWrapper.put({cacheName:s._cacheName,request:e,response:r.clone(),event:t,plugins:s._plugins});if(t)try{t.waitUntil(a)}catch(o){n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${N.getFriendlyURL(t.request.url)}'.`)}return r})()}}var R=Object.freeze({CacheFirst:f,CacheOnly:w,NetworkFirst:v,NetworkOnly:_,StaleWhileRevalidate:k});const q={cacheFirst:f,cacheOnly:w,networkFirst:v,networkOnly:_,staleWhileRevalidate:k},y={};Object.keys(q).forEach(e=>{y[e]=(t={})=>{const s=q[e];return new s(Object.assign(t))}});const F=Object.assign(y,R);return F}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
