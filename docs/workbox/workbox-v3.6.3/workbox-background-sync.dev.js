this.workbox=this.workbox||{},this.workbox.backgroundSync=function(m,h,s,q,l){"use strict";try{self.workbox.v["workbox:background-sync:3.6.3"]=1}catch(e){}const p=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];class o{static fromRequest(e){return babelHelpers.asyncToGenerator(function*(){const t={headers:{}};e.method!=="GET"&&(t.body=yield e.clone().blob());for(const[r,a]of e.headers.entries())t.headers[r]=a;for(const r of p)e[r]!==void 0&&(t[r]=e[r]);return new o({url:e.url,requestInit:t})})()}constructor({url:e,requestInit:t,timestamp:r=Date.now()}){this.url=e,this.requestInit=t,this._timestamp=r}get timestamp(){return this._timestamp}toObject(){return{url:this.url,timestamp:this.timestamp,requestInit:this.requestInit}}toRequest(){return new Request(this.url,this.requestInit)}clone(){const e=Object.assign({},this.requestInit);return e.headers=Object.assign({},this.requestInit.headers),this.requestInit.body&&(e.body=this.requestInit.body.slice()),new o({url:this.url,timestamp:this.timestamp,requestInit:e})}}const f="workbox-background-sync",i="requests",c="queueName",b="workbox-background-sync",_=60*24*7;class k{constructor(e){this._queue=e,this._db=new m.DBWrapper(f,1,{onupgradeneeded:t=>t.target.result.createObjectStore(i,{autoIncrement:!0}).createIndex(c,c,{unique:!1})})}addEntry(e){var t=this;return babelHelpers.asyncToGenerator(function*(){yield t._db.add(i,{queueName:t._queue.name,storableRequest:e.toObject()})})()}getAndRemoveOldestEntry(){var e=this;return babelHelpers.asyncToGenerator(function*(){const[t]=yield e._db.getAllMatching(i,{index:c,query:IDBKeyRange.only(e._queue.name),count:1,includeKeys:!0});if(t)return yield e._db.delete(i,t.primaryKey),new o(t.value.storableRequest)})()}}const d=new Set;class g{constructor(e,{callbacks:t={},maxRetentionTime:r=_}={}){if(d.has(e))throw new h.WorkboxError("duplicate-queue-name",{name:e});d.add(e),this._name=e,this._callbacks=t,this._maxRetentionTime=r,this._queueStore=new k(this),this._addSyncListener()}get name(){return this._name}addRequest(e){var t=this;return babelHelpers.asyncToGenerator(function*(){q.assert.isInstance(e,Request,{moduleName:"workbox-background-sync",className:"Queue",funcName:"addRequest",paramName:"request"});const r=yield o.fromRequest(e.clone());yield t._runCallback("requestWillEnqueue",r),yield t._queueStore.addEntry(r),yield t._registerSync(),s.logger.log(`Request for '${l.getFriendlyURL(r.url)}' has been
          added to background sync queue '${t._name}'.`)})()}replayRequests(){var e=this;return babelHelpers.asyncToGenerator(function*(){const t=Date.now(),r=[],a=[];let n;for(;n=yield e._queueStore.getAndRemoveOldestEntry();){const y=n.clone(),v=e._maxRetentionTime*60*1e3;if(t-n.timestamp>v)continue;yield e._runCallback("requestWillReplay",n);const u={request:n.toRequest()};try{u.response=yield fetch(u.request.clone()),s.logger.log(`Request for '${l.getFriendlyURL(n.url)}'
             has been replayed`)}catch(x){s.logger.log(`Request for '${l.getFriendlyURL(n.url)}'
             failed to replay`),u.error=x,a.push(y)}r.push(u)}if(yield e._runCallback("queueDidReplay",r),a.length)throw yield Promise.all(a.map(function(y){return e._queueStore.addEntry(y)})),new h.WorkboxError("queue-replay-failed",{name:e._name,count:a.length})})()}_runCallback(e,...t){var r=this;return babelHelpers.asyncToGenerator(function*(){typeof r._callbacks[e]=="function"&&(yield r._callbacks[e].apply(null,t))})()}_addSyncListener(){"sync"in registration?self.addEventListener("sync",e=>{e.tag===`${b}:${this._name}`&&(s.logger.log(`Background sync for tag '${e.tag}'
                has been received, starting replay now`),e.waitUntil(this.replayRequests()))}):(s.logger.log("Background sync replaying without background sync event"),this.replayRequests())}_registerSync(){var e=this;return babelHelpers.asyncToGenerator(function*(){if("sync"in registration)try{yield registration.sync.register(`${b}:${e._name}`)}catch(t){s.logger.warn(`Unable to register sync event for '${e._name}'.`,t)}})()}static get _queueNames(){return d}}class w{constructor(...e){this._queue=new g(...e),this.fetchDidFail=this.fetchDidFail.bind(this)}fetchDidFail({request:e}){var t=this;return babelHelpers.asyncToGenerator(function*(){yield t._queue.addRequest(e)})()}}var R=Object.freeze({Queue:g,Plugin:w});return R}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
